// Code generated by typegenerator, DO NOT EDIT.
package conjurpolicy

import yamlv3 "gopkg.in/yaml.v3"

func (p Policy) MarshalYAML() (interface{}, error) {
	type aliasPolicy Policy
	data := aliasPolicy(p)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindPolicy.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (v Variable) MarshalYAML() (interface{}, error) {
	type aliasVariable Variable
	data := aliasVariable(v)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindVariable.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (u User) MarshalYAML() (interface{}, error) {
	type aliasUser User
	data := aliasUser(u)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindUser.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (g Group) MarshalYAML() (interface{}, error) {
	type aliasGroup Group
	data := aliasGroup(g)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindGroup.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (l Layer) MarshalYAML() (interface{}, error) {
	type aliasLayer Layer
	data := aliasLayer(l)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindLayer.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (g Grant) MarshalYAML() (interface{}, error) {
	type aliasGrant Grant
	data := aliasGrant(g)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindGrant.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (h Host) MarshalYAML() (interface{}, error) {
	type aliasHost Host
	data := aliasHost(h)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindHost.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (d Delete) MarshalYAML() (interface{}, error) {
	type aliasDelete Delete
	data := aliasDelete(d)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindDelete.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (p Permit) MarshalYAML() (interface{}, error) {
	type aliasPermit Permit
	data := aliasPermit(p)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindPermit.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (d Deny) MarshalYAML() (interface{}, error) {
	type aliasDeny Deny
	data := aliasDeny(d)
	node := &yamlv3.Node{}
	node.Kind = yamlv3.MappingNode
	if err := node.Encode(data); err != nil {
		return nil, err
	}
	// Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode
	// when the resource struct is empty!
	if len(node.Content) == 0 {
		node.Kind = yamlv3.ScalarNode
	}
	node.Tag = KindDeny.Tag()
	node.Style = yamlv3.TaggedStyle
	return node, nil
}
func (s *PolicyStatements) UnmarshalYAML(value *yamlv3.Node) error {
	var statements []Resource
	for _, node := range value.Content {
		var statement Resource
		switch node.Tag {
		case KindPolicy.Tag():
			var policy Policy
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&policy); err != nil {
					return err
				}
			}
			statement = policy
		case KindVariable.Tag():
			var variable Variable
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&variable); err != nil {
					return err
				}
			}
			statement = variable
		case KindUser.Tag():
			var user User
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&user); err != nil {
					return err
				}
			}
			statement = user
		case KindGroup.Tag():
			var group Group
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&group); err != nil {
					return err
				}
			}
			statement = group
		case KindLayer.Tag():
			var layer Layer
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&layer); err != nil {
					return err
				}
			}
			statement = layer
		case KindGrant.Tag():
			var grant Grant
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&grant); err != nil {
					return err
				}
			}
			statement = grant
		case KindHost.Tag():
			var host Host
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&host); err != nil {
					return err
				}
			}
			statement = host
		case KindDelete.Tag():
			var delete Delete
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&delete); err != nil {
					return err
				}
			}
			statement = delete
		case KindPermit.Tag():
			var permit Permit
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&permit); err != nil {
					return err
				}
			}
			statement = permit
		case KindDeny.Tag():
			var deny Deny
			if len(node.Value) > 0 || len(node.Content) > 0 {
				if err := node.Decode(&deny); err != nil {
					return err
				}
			}
			statement = deny
		}
		statements = append(statements, statement)
	}
	*s = statements
	return nil
}
