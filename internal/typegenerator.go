//go:build tools
// +build tools

package main

import (
	"flag"
	. "github.com/dave/jennifer/jen"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const (
	libYaml      = "gopkg.in/yaml.v3"
	node         = "node"
	err          = "err"
	kind         = "Kind"
	zero         = "0"
	tag          = "Tag"
	content      = "Content"
	statement    = "statement"
	statements   = "statements"
	opEqual      = "="
	opAssignment = ":="
)

func main() {
	var typesStr string
	flag.StringVar(&typesStr, "types", "", "Types to generate methods")
	flag.Parse()
	types := strings.Split(typesStr, " ")
	generate(types...)
}

func generate(inNames ...string) {
	f := NewFile(os.Getenv("GOPACKAGE"))

	f.PackageComment("Code generated by typegenerator, DO NOT EDIT.")
	var cases Statement

	for _, inName := range inNames {
		inShortName := strings.ToLower(inName)[:1]

		// MarshalYAML function generation
		f.Func().Params(
			Id(inShortName).Id(inName),
		).Id("MarshalYAML").Params().Params(
			Interface(),
			Error(),
		).Block(
			Type().Id("alias"+inName).Id(inName),
			Id("data").Op(opAssignment).Id("alias"+inName).Call(Id(inShortName)),
			Id(node).Op(opAssignment).Op("&").Qual(libYaml, "Node").Values(),
			Id(node).Dot(kind).Op(opEqual).Qual(libYaml, "MappingNode"),
			If(Id(err).Op(opAssignment).Id(node).Dot("Encode").Call(Id("data")), Id(err).Op("!=").Nil()).Block(
				Return(Nil(), Id(err))),
			Comment("Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode"),
			Comment("when the resource struct is empty!"),
			If(Len(Id(node).Dot(content)).Op("==").Id(zero)).Block(
				Id(node).Dot(kind).Op(opEqual).Qual(libYaml, "ScalarNode")),
			Id(node).Dot(tag).Op(opEqual).Id(kind+inName).Dot(tag).Call(),
			Id(node).Dot("Style").Op(opEqual).Qual(libYaml, "TaggedStyle"),
			Return(Id(node), Nil()),
		)

		// Prepare cases for UnmarshalYAML
		cases = append(cases, Case(Id(kind+inName+".Tag()")).Block(
			Var().Id(strings.ToLower(inName)).Id(inName),
			If(Len(Id(node).Dot("Value")).Op(">").Id(zero).Op("||").Len(
				Id(node).Dot(content)).Op(">").Id(zero).Block(
				If(Id(err).Op(opAssignment).Id(node).Dot("Decode").Call(Op("&").Id(strings.ToLower(inName))), Id(err).Op("!=").Nil().Block(
					Return(Id(err)),
				)),
			)),
			Id(statement).Op(opEqual).Id(strings.ToLower(inName)),
		))
	}

	// UnmarshalYAML function generation
	f.Func().Params(
		Id("s *PolicyStatements"),
	).Id("UnmarshalYAML").Params(
		Id("value").Op("*").Qual(libYaml, "Node"),
	).Params(Error()).Block(
		Var().Id(statements).Id("[]Resource"),
		For(
			Id("_, ").Id(node).Op(opAssignment).Range().Id("value").Dot(content).Block(
				Var().Id(statement).Id("Resource"),
				Switch(Id(node).Dot(tag)).Block(cases...),
				Id(statements).Op(opEqual).Append(Id(statements), Id(statement)),
			),
		),
		Op("*").Id("s").Op(opEqual).Id(statements),
		Return(Nil()),
	)

	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_gen.go"
	if err := f.Save(targetFilename); err != nil {
		log.Fatal("Error while generating Go file: ", err)
	}
}
