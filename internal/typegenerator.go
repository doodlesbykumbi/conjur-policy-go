//go:build tools
// +build tools

package main

import (
	. "github.com/dave/jennifer/jen"
	"github.com/doodlesbykumbi/conjur-policy-go/pkg/conjurpolicy"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

func main() {
	structType := conjurpolicy.Resources2{}
	generate(structType)
}

func generate(inputType interface{}) {
	f := NewFile(os.Getenv("GOPACKAGE"))

	f.PackageComment("Code generated by typegenerator, DO NOT EDIT.")
	var cases Statement
	structType := reflect.TypeOf(inputType)
	for i := 0; i < structType.NumField(); i++ {
		field := structType.Field(i)
		v := strings.ToLower(field.Name)[:1]

		// MarshalYAML function generation
		f.Func().Params(
			Id(v).Id(field.Name),
		).Id("MarshalYAML").Params().Params(
			Interface(),
			Error(),
		).Block(
			Type().Id("alias"+field.Name).Id(field.Name),
			Id("data").Op(":=").Id("alias"+field.Name).Call(Id(v)),
			Id("node").Op(":=").Op("&").Qual("gopkg.in/yaml.v3", "Node").Values(),
			Id("node.Kind").Op("=").Qual("gopkg.in/yaml.v3", "MappingNode"),
			If(Id("err").Op(":=").Id("node").Dot("Encode").Call(Id("data")), Id("err").Op("!=").Nil()).Block(
				Return(Nil(), Id("err"))),
			Comment("Avoid emitting strings like `- !variable {}` and instead emit `- !variable` by setting Kind to ScalarNode"),
			Comment("when the resource struct is empty!"),
			If(Len(Id("node").Dot("Content")).Op("==").Id("0")).Block(
				Id("node").Dot("Kind").Op("=").Qual("gopkg.in/yaml.v3", "ScalarNode")),
			Id("node").Dot("Tag").Op("=").Id("Kind"+field.Name).Dot("Tag").Call(),
			Id("node").Dot("Style").Op("=").Qual("gopkg.in/yaml.v3", "TaggedStyle"),
			Return(Id("node"), Nil()),
		)

		// Prepare cases for UnmarshalYAML
		cases = append(cases, Case(Id("Kind"+field.Name+".Tag()")).Block(
			Var().Id(strings.ToLower(field.Name)).Id(field.Name),
			If(Len(Id("node").Dot("Value")).Op(">").Id("0").Op("||").Len(
				Id("node").Dot("Content")).Op(">").Id("0").Block(
				If(Id("err").Op(":=").Id("node").Dot("Decode").Call(Op("&").Id(strings.ToLower(field.Name))), Id("err").Op("!=").Nil().Block(
					Return(Id("err")),
				)),
			)),
			Id("statement").Op("=").Id(strings.ToLower(field.Name)),
		))
	}

	// UnmarshalYAML function generation
	f.Func().Params(
		Id("s *PolicyStatements"),
	).Id("UnmarshalYAML").Params(
		Id("value").Op("*").Qual("gopkg.in/yaml.v3", "Node"),
	).Params(Error()).Block(
		Var().Id("statements").Id("[]Resource"),
		For(
			Id("_, ").Id("node").Op(":=").Range().Id("value").Dot("Content").Block(
				Var().Id("statement").Id("Resource"),
				Switch(Id("node").Dot("Tag")).Block(cases...),
				Id("statements").Op("=").Append(Id("statements"), Id("statement")),
			),
		),
		Op("*").Id("s").Op("=").Id("statements"),
		Return(Nil()),
	)

	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_gen.go"
	if err := f.Save(targetFilename); err != nil {
		log.Fatal("Error while generating Go file: ", err)
	}
}
